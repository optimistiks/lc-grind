/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function (graph, initial) {
  const parents = Array.from({ length: graph.length }).map((_, index) => index);
  const ranks = Array.from({ length: graph.length }).map(() => 0);

  const find = (v) => {
    if (parents[v] !== v) {
      parents[v] = find(parents[v]);
    }
    return parents[v];
  };

  const union = (a, b) => {
    const aParent = find(a);
    const bParent = find(b);
    if (aParent === bParent) {
      return;
    }
    const aParentRank = ranks[aParent] ?? 0;
    const bParentRank = ranks[bParent] ?? 0;
    if (aParentRank >= bParentRank) {
      parents[bParent] = aParent;
      ranks[aParent] = aParentRank + 1;
      ranks[bParent] = bParentRank;
    } else {
      parents[aParent] = bParent;
      ranks[aParent] = aParentRank;
      ranks[bParent] = bParentRank + 1;
    }
  };

  for (let i = 0; i < graph.length; ++i) {
    for (let j = 0; j < graph[i].length; ++j) {
      if (graph[i][j] === 1) {
        union(i, j);
      }
    }
  }

  // find each initially infected node parent
  // and count how many initially infected nodes each parent has
  const infected = {};
  initial.forEach((node) => {
    const parent = find(node);
    infected[parent] = (infected[parent] ?? 0) + 1;
  });

  let found = null;
  let foundSize = null;

  initial.forEach((node) => {
    const parent = find(node);
    if (infected[parent] !== 1) {
      // if 2 or more, it means this connected component
      // has another node that is initially infected
      // so removing this node will do nothing
      // because the whole connected component will become infected again
      // from that other node
      return;
    }
    const size = ranks[parent];
    if (foundSize === null || size > foundSize) {
      foundSize = size;
      found = node;
    } else if (found && size === foundSize && node < found) {
      found = node;
    }
  });

  return found ?? Math.min(...initial);
};
